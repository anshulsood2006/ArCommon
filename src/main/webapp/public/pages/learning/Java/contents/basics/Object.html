<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Object</title>
</head>
<body>
<h2><a href="../../Content.html">Back</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../Content.html">Home</a></h2>
<h1>Object</h1>
<h1>Features</h1>
<p>Methods of Object Class:  There are total 11 methods in Object class</p>

<ol>
<li>protected  native Object clone() throws CloneNotSupportedException</li>
<li>public native final void notify()</li>
<li>public native final void notifyAll()</li>
<li>public native final void wait(long timeout) throws InterruptedException</li>
<li>public native final void wait(long timeout, int nanoseconds) throws InterruptedException</li>
<li>public native final void wait() throws InterruptedException</li>
<li>public native final Class getClass()</li>
<li>public native int hashCode()</li>
<li>protected void finalize() throws Throwable { }</li>
<li><pre>public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}</pre></li>
<li><pre>public boolean equals(Object obj) {
	return (this == obj);
}</pre></li>
</ol>
<h1>wait, notify and notifyAll()</h1>
<p>All the three methods are called on an object by a thread. The thread should be having the monitor object else java.lang.IllegalMonitorStateException exception is thrown.</p>
<ul>
<li><b>wait(): This method has three variances</b>
<ul>
<li><b>wait(): </b>The thread waits indefinitely for any other thread to call notify or notifyAll method on the monitor object to wake up the current thread.</li>
<li><b>wait(long timeout): </b>The thread waits for any other thread to call notify or notifyAll method on the monitor object to wake up the current thread or waits for specified period which ever happens earlier</li>
<li><b>wait(long timeout, int timeout): </b>The thread waits for any other thread to call notify or notifyAll method on the monitor object to wake up the current thread or waits for specified period (1000000*timeout+nanos nanoseconds) which ever happens earlier</li>
</ul>	
</li>
<li><b>notify(): </b>This method when called on monitor object, wakes up only one thread which is waiting for monitor on that object.</li>
<li><b>notifyAll(): </b>This method when called on monitor object, wakes up all the threads which are waiting for monitor on that object.</li>
</ul>
<h1>Examples</h1>
<h1>wait, notify and notifyAll()</h1>
<pre>

//The object on which monitor will be obtained
public class ArMessage {
	
	private String message;
	
	public ArMessage(String message) {
		this.message = message;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
	
}

//The class that will be waiting for other threads to invoke notify method
public class ArWaiter implements Runnable {

	private ArMessage arMessage;
	
	public ArWaiter(ArMessage arMessage) {
		this.arMessage = arMessage;
	}
	
	@Override
	public void run() {
		synchronized (arMessage) {
			try {
				System.out.println("ArWaiter is waiting.");
				arMessage.wait();
			}catch(InterruptedException ex) {
				System.out.println("InterruptedException is thrown inside ArNotifier.");
			}
			System.out.println("ArWaiter is notified and "+arMessage.getMessage()+" is received successfully.");
		}
	}

}

//The class that will notify one or all the waiting threads based on whether notify or notifyAll is called.
public class ArNotifier implements Runnable{

private ArMessage arMessage;
	
	public ArNotifier(ArMessage arMessage) {
		this.arMessage = arMessage;
	}
	
	@Override
	public void run() {
		try {
			Thread.sleep(1000);
			synchronized (arMessage) {
				System.out.println("ArNotifier is notifying.");
				arMessage.notifyAll();
				
        		}
		}catch(InterruptedException ex) {
			System.out.println("InterruptedException is thrown inside ArNotifier.");
		}
	}

}

// The class to test the wait and notify/notifyAll
public class ArWaiterNotifier {
	 public static void main(String[] args) {
        ArMessage msg = new ArMessage("process it");
        ArWaiter waiter = new ArWaiter(msg);
        new Thread(waiter).start();
        
        ArWaiter waiter1 = new ArWaiter(msg);
        new Thread(waiter1).start();
        
        ArNotifier notifier = new ArNotifier(msg);
        new Thread(notifier).start();
        System.out.println("All the threads are started");
    }
}
</pre>
Note: Here in ArWaiterNotifier, two waiter threads are created both of which have called wait() on the common arMessage object.
<ul>
	<li>If notifier object calls notify() method, only one thread will get notified. The program will never terminate.</li>
	<li>If notifier object calls notifyAll() method, both the threads will get notified. The program will terminate.</li>
</ul>
This will not work all the time. If the notifier thread get the lock first, its notify() call will be ignored and other threads will always be waiting. To avoid this we have called Thread.sleep(1000) method. This will make sure that the two waiter threads are started before notifier is started.
<h1>Frequently Asked Questions</h1>
<p><b>Which are protected methods in Object class?</b></p>
<p>clone() and finalize()</p>
<p><b>Which methods are non native in Object class?</b></p>
<p>equals(), finalize() and toString()</p>
<p><b>Which methods are non final in Object class?</b></p>
<p>clone(), hashCode(), equals() and toString()</p>
<p><b>How many methods are protected, how many are non native and how many are non-final in Object class?</b></p>
<p>Out of total 11 methods in Object class: </p>
<ul>
<li>2 are protected viz. clone() and finalize() and rest 9 are public. (See above)</li>
<li>3 are non-native viz. equals(), finalize() and toString() and rest 8 are native. (See above)</li>
<li>4 are non-final viz. clone(), hashCode(), equals() and toString() and rest 7 are final. (See above)</li>
</ul>
<p><b>Can the native methods be over-ridden in Java?</b><p>
<p>Yes, clone() and hashCode() are the native methods which are usually over-ridden in Java as per the requirement.</p>
<p><b>Why wait(), notify and notifyAll() methods are in Object class?</b><p>
<p>In the Java language, we wait() on a particular instance of an object. If we want to send a signal to one thread that is waiting on that specific object instance then we call notify() on that object. If we want to send a signal to all threads that are waiting on that object instance, you we notifyAll() on that object. If wait() and notify() were on the Thread instead then each thread would have to know the status of every other thread. How would thread1 know that thread2 was waiting for access to a particular resource? If thread1 needed to call thread2.notify() it would have to somehow find out that thread2 was waiting. There would need to be some mechanism for threads to register the resources or actions that they need so others could signal them when stuff was ready or available. The object itself is the entity that is shared between threads which allows them to communicate with each other. The threads have no specific knowledge of each other and they can run asynchronously. They run and they lock, wait, and notify on the object that they want to get access to. They have no knowledge of other threads and don't need to know their status. They don't need to know that it is thread2 which is waiting for the resource : they just notify on the resource and whomever it is that is waiting (if anyone) will be notified.
</p>
<h2><a href="../../Content.html">Back</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../Content.html">Home</a></h2>
</body>
</html>